# -*- coding: utf-8 -*-
"""Untitled18.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-iyqOVtEhanoR72Hv5S1eBXKx1lBNpML
"""

#Task1

def Infix2Postfix(infix):
    precedence = {
        '~': 4,  # NOT
        '&': 3,  # AND
        '|': 2,  # OR
        '>': 1,  # IMPLIES
        '=': 0   # IFF
    }
    right_associative = {'~'}  # Only NOT is right-associative

    def is_operator(c):
        return c in precedence

    def is_operand(c):
        return c.isalpha() and c.isupper()  # A-Z

    output = []
    stack = []

    for token in infix:
        if token == ' ':
            continue
        elif is_operand(token):
            output.append(token)
        elif token == '(':
            stack.append(token)
        elif token == ')':
            while stack and stack[-1] != '(':
                output.append(stack.pop())
            stack.pop()  # Remove '('
        elif is_operator(token):
            while (stack and stack[-1] != '(' and
                   ((precedence[token] < precedence[stack[-1]]) or
                    (precedence[token] == precedence[stack[-1]] and token not in right_associative))):
                output.append(stack.pop())
            stack.append(token)

    while stack:
        output.append(stack.pop())

    return ''.join(output)

import itertools

def Postfix2Truthtable(postfix):
    operators = {'~', '&', '|', '>', '='}

    # Extract unique variables from the postfix expression
    variables = sorted(set(filter(str.isalpha, postfix)))

    # Generate all possible combinations of truth values (0 = False, 1 = True)
    combinations = list(itertools.product([0, 1], repeat=len(variables)))

    def eval_postfix(expr, values):
        stack = []
        env = dict(zip(variables, values))

        for token in expr:
            if token.isalpha():
                stack.append(env[token])
            elif token == '~':
                a = stack.pop()
                stack.append(int(not a))
            elif token == '&':
                b = stack.pop()
                a = stack.pop()
                stack.append(a & b)
            elif token == '|':
                b = stack.pop()
                a = stack.pop()
                stack.append(a | b)
            elif token == '>':
                b = stack.pop()
                a = stack.pop()
                stack.append(int((not a) | b))
            elif token == '=':
                b = stack.pop()
                a = stack.pop()
                stack.append(int(a == b))
        return stack[0]

    # Print header
    header = ' | '.join(variables) + ' | Result'
    line = '-' * len(header)
    print(header)
    print(line)

    for combo in combinations:
        result = eval_postfix(postfix, combo)
        row = ' | '.join(str(val) for val in combo) + f' |   {result}'
        print(row)

print("\nTest 1: R|(P&Q)")
Postfix2Truthtable("RPQ&|")

print("\nTest 2: ~P|(Q&R)>R")
Postfix2Truthtable("P~QR&|R>")

print("\nTest 3: P|(R&Q)")
Postfix2Truthtable("PRQ&|")

print("\nTest 4: (P>Q)&(Q>R)")
Postfix2Truthtable("PQ>QR>&")

print("\nTest 5: (P|~Q)>~P")
Postfix2Truthtable("PQ~|P~>")

#Task2
import csv
import random

def is_passing(student):
    return all(int(score) >= 5 for score in student[3:])

def is_high_math(student):
    return int(student[3]) >= 9

def is_struggling(student):
    return student[3] < 6 and student[4] < 6

def improved_in_cs(student):
    return student[4] > student[3]

def load_data(filename):
    with open(filename, 'r') as file:
        reader = csv.reader(file)
        next(reader)  # Skip header row
        return list(reader)

# Universal Quantifications
def all_students_passed(students):
    return all(is_passing(student) for student in students)

def all_students_math_above_3(students):
        return all(int(student[3]) > 3 for student in students)

# Existential Quantifications
def exists_student_high_math(students):
    return any(is_high_math(student) for student in students)

def exists_student_improved_cs(students):
    return any(improved_in_cs(student) for student in students)

# Combined/Nested Statements
def for_all_exists_subject_above_6(students):
        return all(any(int(score) > 6 for score in student[3:]) for student in students)

def for_all_math_below_6_exists_subject_above_6(students):
        return all(any(int(score) > 6 for score in student[3:]) for student in students if int(student[3]) < 6)

# Negations
def not_all_students_passed(students):
    # Meaning: "There exists at least one student who did not pass all subjects."
    return not all_students_passed(students)

def not_all_students_math_above_3(students):
    # Meaning: "There exists at least one student with a math score less than or equal to 3."
    return not all_students_math_above_3(students)

def not_exists_student_high_math(students):
    # Meaning: "No student scored above 9 in math."
    return not exists_student_high_math(students)

def not_exists_student_improved_cs(students):
    # Meaning: "No student improved in CS over Math."
    return not exists_student_improved_cs(students)

def not_for_all_exists_subject_above_6(students):
    # Meaning: "There exists at least one student who did not score above 6 in any subject."
    return not for_all_exists_subject_above_6(students)

def not_for_all_math_below_6_exists_subject_above_6(students):
    # Meaning: "There exists at least one student scoring below 6 in Math who did not score above 6 in any other subject."
    return not for_all_math_below_6_exists_subject_above_6(students)

# Generate random student data
data = []
for i in range(20):
    student_id = f"S{i+1:03}"
    student_name = f"Student {i+1}"
    day_of_birth = f"200{random.randint(0, 9)}-{random.randint(1, 12):02}-{random.randint(1, 28):02}"
    math_score = random.randint(0, 10)
    cs_score = random.randint(0, 10)
    eng_score = random.randint(0, 10)
    data.append([student_id, student_name, day_of_birth, math_score, cs_score, eng_score])

# Write data to CSV file
with open('students.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(["StudentID", "StudentName", "DayOfBirth", "Math", "CS", "Eng"])
    writer.writerows(data)

print("Dataset 'students.csv' created successfully.\n")

students = load_data('students.csv')

# Test the functions
print("All students passed all subjects:", all_students_passed(students))
print("All students have a math score higher than 3:", all_students_math_above_3(students))
print("There exists a student who scored above 9 in math:", exists_student_high_math(students))
print("There exists a student who improved in CS over Math:", exists_student_improved_cs(students))
print("For every student, there exists a subject in which they scored above 6:", for_all_exists_subject_above_6(students))
print("For every student scoring below 6 in Math, there exists a subject where they scored above 6:", for_all_math_below_6_exists_subject_above_6(students))

# Test the negations
print("\nNegations:")
print("Not all students passed all subjects:", not_all_students_passed(students))
print("Not all students have a math score higher than 3:", not_all_students_math_above_3(students))
print("No student scored above 9 in math:", not_exists_student_high_math(students))
print("No student improved in CS over Math:", not_exists_student_improved_cs(students))
print("There exists at least one student who did not score above 6 in any subject:", not_for_all_exists_subject_above_6(students))
print("There exists at least one student scoring below 6 in Math who did not score above 6 in any other subject:", not_for_all_math_below_6_exists_subject_above_6(students))

#Task3
import rsa
import time
import matplotlib.pyplot as plt

def generate_keys():
    """Generates public and private keys using RSA."""
    (pubkey, privkey) = rsa.newkeys(2048) # Generate 2048-bit keys
    return pubkey, privkey

def encrypt(message, pubkey, chunk_size=245):
    ciphertext_chunks = []
    for i in range(0, len(message), chunk_size):
        chunk = message[i:i + chunk_size]
        ciphertext_chunk = rsa.encrypt(chunk.encode('utf-8'), pubkey)
        ciphertext_chunks.append(ciphertext_chunk)
    return ciphertext_chunks

def decrypt(ciphertext, privkey):
    decrypted_chunks = []
    for chunk in ciphertext:
        decrypted_chunk = rsa.decrypt(chunk, privkey).decode('utf-8')
        decrypted_chunks.append(decrypted_chunk)
    return ''.join(decrypted_chunks)

# Example usage
pubkey, privkey = generate_keys()
message = "This is a secret message!"
ciphertext = encrypt(message, pubkey)
decrypted_message = decrypt(ciphertext, privkey)

print("Original message:", message)
print("Encrypted message:", ciphertext)
print("Decrypted message:", decrypted_message)

message_lengths = [10, 100, 1000, 10000]
encryption_times = []
decryption_times = []

for length in message_lengths:
    message = 'a' * length

    start_time = time.time()
    ciphertext = encrypt(message, pubkey)
    encryption_times.append(time.time() - start_time)

    start_time = time.time()
    decrypted_message = decrypt(ciphertext, privkey)
    decryption_times.append(time.time() - start_time)

plt.plot(message_lengths, encryption_times, label='Encryption Time')
plt.plot(message_lengths, decryption_times, label='Decryption Time')
plt.xlabel('Plaintext Message Length')
plt.ylabel('Time (seconds)')
plt.title('RSA Encryption/Decryption Time vs. Message Length')
plt.legend()
plt.show()